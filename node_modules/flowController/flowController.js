/*
 * Copyright 2015 SitScape, inc
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var options = JSON.parse(process.argv[2]);
//TODO: Need a robust way of giving random params if necessary ones are not present.
var extend = require('../extend');
var events = require('../node-red/red/events');
//var emitter = new EventEmitter();
var http = require('http');
var express = require("../express");
var RED = require("../node-red");

// Create an Express app
var app = express();

app.use(function auth(req, res, next){
//    console.log('child url...for ' + req.url);
    next();
});

// Create a server
var REDserver = http.createServer(app);

// Create the settings object - see default settings.js file for other options
var settings = {
    httpAdminRoot:"/esb-server/red/"+options.id,
    httpNodeRoot: "/esb-server/api/"+options.id,
    userDir:"/home/nol/.nodered/"+options.id+"/",
    flows : {
        id : options.id
    },
    functionGlobalContext: { }    // enables global context
};
settings = extend(true,options.RedSettings, settings);  //Brings in settings from global controller

// Initialise the runtime with a server and settings
RED.init(REDserver,settings);

// Serve the editor UI from /red
app.use(settings.httpAdminRoot,RED.httpAdmin);

// Serve the http nodes UI from /api
app.use(settings.httpNodeRoot,RED.httpNode);

if(options.listenPort){
    REDserver.listen(options.listenPort, '', '', function(){
        process.send({command:"flows created"});
    });
    
}
//set up storage to save state
var storage = require('node-red/red/storage');
process.on('message', function(message, server){
    switch(message.command){
        case 'startFlow':
            console.log('Initializing flow...');
            //set up the listener for when it is done
            events.once("flows initialized", function(){
                process.send({command:"flows initialized"});
            });
            // Start the runtime
            var prom = RED.start();
            prom.done(function(dunno){ //dunno is redNodes object
                console.log("RED started on port : " + options.listenPort);
                storage.saveState(options.id, 'paused');
            });
            break;
        case 'pauseFlow':
            events.once("nodes-stopped", function(){
                process.send({command:"nodes-stopped"});
            });
            var prom = RED.pause();
            prom.done(function(){
                storage.saveState(options.id, 'paused');
            });
            break;
        case 'resumeFlow':
            events.once("nodes-started", function(){
                process.send({command:"nodes-started"});
            });
            var prom = RED.resume();
            prom.done(function(){
                storage.saveState(options.id, 'running');
            });
            break;
        case 'stopFlow':
            var prom = RED.stop();
            prom.done(function(){
                storage.saveState(options.id, 'created');
                console.log('RED stopped on port : ' + options.listenPort);
            });
            break;
        case 'destroyFlow':
            var prom = RED.stop();
            prom.done(function(){
                storage.deleteFlows().then(function(result){
                    process.exit();
                }, function(err){
                    console.log(err.message);
                    process.exit();
                });
            });
            break;
        case 'shutdownFlow':
            var prom = RED.stop();
            prom.done(function(){
                process.exit();
            });
            break;
    }
});
events.on("nodes-started", function(someVar){
    console.log("node flow started");
});
events.on("nodes-stopped", function(somevar){
    console.log("node flow stopped");
});